<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Lista2/L2_Ex06.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Lista2/L2_Ex06.cpp" />
              <option name="originalContent" value="/*&#10; * L2_Ex06 - Exercício 6 da Lista 2&#10; * Criar triângulos a partir do clique do mouse&#10; *&#10; * Adaptado por: Rossana Baptista Queiroz&#10; *&#10; * Disciplinas:&#10; *   - Processamento Gráfico (Ciência da Computação - Híbrido)&#10; *   - Processamento Gráfico: Fundamentos (Ciência da Computação - Presencial)&#10; *   - Fundamentos de Computação Gráfica (Jogos Digitais)&#10; *&#10; * Descrição:&#10; *   Este exercício permite criar triângulos clicando na tela. A cada 3 cliques,&#10; *   um novo triângulo é criado com uma cor aleatória.&#10; *&#10; * Histórico:&#10; *   - Versão inicial: 07/04/2017&#10; *   - Última atualização: 18/03/2025&#10; *&#10; */&#10;&#10;#include &lt;iostream&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;ctime&gt;&#10;&#10;using namespace std;&#10;&#10;// GLAD&#10;#include &lt;glad/glad.h&gt;&#10;&#10;// GLFW&#10;#include &lt;GLFW/glfw3.h&gt;&#10;&#10;// GLM&#10;#include &lt;glm/glm.hpp&gt; &#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &lt;glm/gtc/type_ptr.hpp&gt;&#10;&#10;using namespace glm;&#10;&#10;// Estrutura para armazenar vértices&#10;struct Vertex {&#10;    float x, y, z;&#10;    float r, g, b;&#10;};&#10;&#10;// Variáveis globais&#10;vector&lt;Vertex&gt; vertices;&#10;vector&lt;Vertex&gt; currentTriangle;&#10;GLuint VAO, VBO;&#10;int triangleCount = 0;&#10;&#10;// Protótipos das funções&#10;void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode);&#10;void mouse_button_callback(GLFWwindow* window, int button, int action, int mods);&#10;int setupShader();&#10;void updateGeometry();&#10;vec3 generateRandomColor();&#10;&#10;// Dimensões da janela&#10;const GLuint WIDTH = 800, HEIGHT = 600;&#10;&#10;// Código fonte do Vertex Shader (em GLSL)&#10;const GLchar *vertexShaderSource = R&quot;(&#10; #version 400&#10; layout (location = 0) in vec3 position;&#10; layout (location = 1) in vec3 color;&#10; out vec3 vColor; &#10; uniform mat4 projection;&#10; void main()&#10; {&#10;&#9; gl_Position = projection * vec4(position.x, position.y, position.z, 1.0);&#10;&#9; vColor = color;&#10; }&#10; )&quot;;&#10;&#10;// Código fonte do Fragment Shader (em GLSL)&#10;const GLchar *fragmentShaderSource = R&quot;(&#10; #version 400&#10; in vec3 vColor;&#10; out vec4 color;&#10; void main()&#10; {&#10;&#9; color = vec4(vColor,1.0);&#10; }&#10; )&quot;;&#10;&#10;// Função MAIN&#10;int main()&#10;{&#10;&#9;// Inicialização da GLFW&#10;&#9;glfwInit();&#10;&#10;&#9;// Inicializa gerador de números aleatórios&#10;&#9;srand(time(nullptr));&#10;&#10;&#9;// Criação da janela GLFW&#10;&#9;GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, &quot;L2_Ex06 - Criar Triângulos com Mouse -- Taimisson&quot;, nullptr, nullptr);&#10;&#9;if (!window)&#10;&#9;{&#10;&#9;&#9;std::cerr &lt;&lt; &quot;Falha ao criar a janela GLFW&quot; &lt;&lt; std::endl;&#10;&#9;&#9;glfwTerminate();&#10;&#9;&#9;return -1;&#10;&#9;}&#10;&#9;glfwMakeContextCurrent(window);&#10;&#10;&#9;// Registrando callbacks&#10;&#9;glfwSetKeyCallback(window, key_callback);&#10;&#9;glfwSetMouseButtonCallback(window, mouse_button_callback);&#10;&#10;&#9;// GLAD: carrega todos os ponteiros de funções da OpenGL&#10;&#9;if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#10;&#9;{&#10;&#9;&#9;std::cerr &lt;&lt; &quot;Falha ao inicializar GLAD&quot; &lt;&lt; std::endl;&#10;&#9;&#9;return -1;&#10;&#9;}&#10;&#10;&#9;// Obtendo as informações de versão&#10;&#9;const GLubyte *renderer = glGetString(GL_RENDERER);&#10;&#9;const GLubyte *version = glGetString(GL_VERSION);&#10;&#9;cout &lt;&lt; &quot;Renderer: &quot; &lt;&lt; renderer &lt;&lt; endl;&#10;&#9;cout &lt;&lt; &quot;OpenGL version supported &quot; &lt;&lt; version &lt;&lt; endl;&#10;&#10;&#9;// Compilando e buildando o programa de shader&#10;&#9;GLuint shaderID = setupShader();&#10;&#10;&#9;// Configuração inicial do VAO e VBO&#10;&#9;glGenVertexArrays(1, &amp;VAO);&#10;&#9;glGenBuffers(1, &amp;VBO);&#10;&#10;&#9;glUseProgram(shaderID);&#10;&#10;&#9;double prev_s = glfwGetTime();&#10;&#9;double title_countdown_s = 0.1;&#10;&#10;&#9;// Criação da matriz de projeção - coordenadas de tela (0,800,600,0)&#10;&#9;mat4 projection = ortho(0.0f, (float)WIDTH, (float)HEIGHT, 0.0f, -1.0f, 1.0f);&#10;&#10;&#9;// Mandar a matriz de projeção para o shader&#10;&#9;glUniformMatrix4fv(glGetUniformLocation(shaderID, &quot;projection&quot;), 1, GL_FALSE, value_ptr(projection));&#10;&#10;&#9;cout &lt;&lt; &quot;Clique na tela para criar vértices. A cada 3 cliques, um triângulo será criado!&quot; &lt;&lt; endl;&#10;&#9;cout &lt;&lt; &quot;Pressione ESC para sair.&quot; &lt;&lt; endl;&#10;&#10;&#9;// Loop da aplicação - &quot;game loop&quot;&#10;&#9;while (!glfwWindowShouldClose(window))&#10;&#9;{&#10;&#9;&#9;// Calcula e mostra o FPS na barra de título&#10;&#9;&#9;{&#10;&#9;&#9;&#9;double curr_s = glfwGetTime();&#10;&#9;&#9;&#9;double elapsed_s = curr_s - prev_s;&#10;&#9;&#9;&#9;prev_s = curr_s;&#10;&#10;&#9;&#9;&#9;title_countdown_s -= elapsed_s;&#10;&#9;&#9;&#9;if (title_countdown_s &lt;= 0.0 &amp;&amp; elapsed_s &gt; 0.0)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;double fps = 1.0 / elapsed_s;&#10;&#9;&#9;&#9;&#9;char tmp[256];&#10;&#9;&#9;&#9;&#9;sprintf(tmp, &quot;L2_Ex06 - Triângulos: %d, Vértices: %d/3 -- FPS %.2lf&quot;,&#10;&#9;&#9;&#9;&#9;&#9;triangleCount, (int)currentTriangle.size(), fps);&#10;&#9;&#9;&#9;&#9;glfwSetWindowTitle(window, tmp);&#10;&#9;&#9;&#9;&#9;title_countdown_s = 0.1;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Checa eventos de input&#10;&#9;&#9;glfwPollEvents();&#10;&#10;&#9;&#9;// Limpa o buffer de cor&#10;&#9;&#9;glClearColor(0.2f, 0.2f, 0.2f, 1.0f); // Fundo cinza escuro&#10;&#9;&#9;glClear(GL_COLOR_BUFFER_BIT);&#10;&#10;&#9;&#9;// Viewport para tela inteira&#10;&#9;&#9;glViewport(0, 0, WIDTH, HEIGHT);&#10;&#10;&#9;&#9;// Desenha todos os triângulos criados&#10;&#9;&#9;if (!vertices.empty())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;glBindVertexArray(VAO);&#10;&#9;&#9;&#9;glDrawArrays(GL_TRIANGLES, 0, vertices.size());&#10;&#9;&#9;&#9;glBindVertexArray(0);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Desenha os vértices do triângulo atual sendo criado como pontos&#10;&#9;&#9;if (!currentTriangle.empty())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;glPointSize(8.0f);&#10;&#10;&#9;&#9;&#9;// Cria um VAO temporário para os pontos&#10;&#9;&#9;&#9;GLuint tempVAO, tempVBO;&#10;&#9;&#9;&#9;glGenVertexArrays(1, &amp;tempVAO);&#10;&#9;&#9;&#9;glGenBuffers(1, &amp;tempVBO);&#10;&#10;&#9;&#9;&#9;glBindVertexArray(tempVAO);&#10;&#9;&#9;&#9;glBindBuffer(GL_ARRAY_BUFFER, tempVBO);&#10;&#9;&#9;&#9;glBufferData(GL_ARRAY_BUFFER, currentTriangle.size() * sizeof(Vertex), currentTriangle.data(), GL_DYNAMIC_DRAW);&#10;&#10;&#9;&#9;&#9;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);&#10;&#9;&#9;&#9;glEnableVertexAttribArray(0);&#10;&#9;&#9;&#9;glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(3 * sizeof(float)));&#10;&#9;&#9;&#9;glEnableVertexAttribArray(1);&#10;&#10;&#9;&#9;&#9;glDrawArrays(GL_POINTS, 0, currentTriangle.size());&#10;&#10;&#9;&#9;&#9;// Limpa VAO temporário&#10;&#9;&#9;&#9;glDeleteVertexArrays(1, &amp;tempVAO);&#10;&#9;&#9;&#9;glDeleteBuffers(1, &amp;tempVBO);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Troca os buffers da tela&#10;&#9;&#9;glfwSwapBuffers(window);&#10;&#9;}&#10;&#10;&#9;// Limpeza&#10;&#9;glDeleteVertexArrays(1, &amp;VAO);&#10;&#9;glDeleteBuffers(1, &amp;VBO);&#10;&#9;glfwTerminate();&#10;&#9;return 0;&#10;}&#10;&#10;// Função de callback de teclado&#10;void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode)&#10;{&#10;&#9;if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)&#10;&#9;&#9;glfwSetWindowShouldClose(window, GL_TRUE);&#10;}&#10;&#10;// Função de callback do mouse&#10;void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)&#10;{&#10;&#9;if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; action == GLFW_PRESS)&#10;&#9;{&#10;&#9;&#9;double xpos, ypos;&#10;&#9;&#9;glfwGetCursorPos(window, &amp;xpos, &amp;ypos);&#10;&#10;&#9;&#9;// Converte coordenadas da tela para coordenadas do mundo&#10;&#9;&#9;float worldX = (float)xpos;&#10;&#9;&#9;float worldY = (float)ypos;&#10;&#10;&#9;&#9;// Gera cor para este vértice (será a cor do triângulo quando completado)&#10;&#9;&#9;static vec3 currentColor = generateRandomColor();&#10;&#10;&#9;&#9;// Cria o vértice&#10;&#9;&#9;Vertex vertex;&#10;&#9;&#9;vertex.x = worldX;&#10;&#9;&#9;vertex.y = worldY;&#10;&#9;&#9;vertex.z = 0.0f;&#10;&#9;&#9;vertex.r = currentColor.r;&#10;&#9;&#9;vertex.g = currentColor.g;&#10;&#9;&#9;vertex.b = currentColor.b;&#10;&#10;&#9;&#9;// Adiciona o vértice ao triângulo atual&#10;&#9;&#9;currentTriangle.push_back(vertex);&#10;&#10;&#9;&#9;cout &lt;&lt; &quot;Vértice &quot; &lt;&lt; currentTriangle.size() &lt;&lt; &quot; criado em (&quot; &lt;&lt; worldX &lt;&lt; &quot;, &quot; &lt;&lt; worldY &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#10;&#10;&#9;&#9;// Se completou um triângulo (3 vértices)&#10;&#9;&#9;if (currentTriangle.size() == 3)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// Adiciona os 3 vértices aos triângulos finalizados&#10;&#9;&#9;&#9;for (const auto&amp; v : currentTriangle)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;vertices.push_back(v);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;triangleCount++;&#10;&#9;&#9;&#9;cout &lt;&lt; &quot;Triângulo &quot; &lt;&lt; triangleCount &lt;&lt; &quot; criado!&quot; &lt;&lt; endl;&#10;&#10;&#9;&#9;&#9;// Atualiza a geometria no OpenGL&#10;&#9;&#9;&#9;updateGeometry();&#10;&#10;&#9;&#9;&#9;// Limpa o triângulo atual e gera nova cor para o próximo&#10;&#9;&#9;&#9;currentTriangle.clear();&#10;&#9;&#9;&#9;currentColor = generateRandomColor();&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// Função para configurar os shaders&#10;int setupShader()&#10;{&#10;&#9;// Vertex shader&#10;&#9;GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);&#10;&#9;glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);&#10;&#9;glCompileShader(vertexShader);&#10;&#10;&#9;GLint success;&#10;&#9;GLchar infoLog[512];&#10;&#9;glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;// Fragment shader&#10;&#9;GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);&#10;&#9;glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);&#10;&#9;glCompileShader(fragmentShader);&#10;&#10;&#9;glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;// Linkando os shaders&#10;&#9;GLuint shaderProgram = glCreateProgram();&#10;&#9;glAttachShader(shaderProgram, vertexShader);&#10;&#9;glAttachShader(shaderProgram, fragmentShader);&#10;&#9;glLinkProgram(shaderProgram);&#10;&#10;&#9;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;glDeleteShader(vertexShader);&#10;&#9;glDeleteShader(fragmentShader);&#10;&#10;&#9;return shaderProgram;&#10;}&#10;&#10;// Atualiza a geometria no OpenGL&#10;void updateGeometry()&#10;{&#10;&#9;if (vertices.empty()) return;&#10;&#10;&#9;glBindVertexArray(VAO);&#10;&#9;glBindBuffer(GL_ARRAY_BUFFER, VBO);&#10;&#10;&#9;// Envia todos os vértices para o buffer&#10;&#9;glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_DYNAMIC_DRAW);&#10;&#10;&#9;// Configura os atributos dos vértices&#10;&#9;// Posição (x, y, z)&#10;&#9;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);&#10;&#9;glEnableVertexAttribArray(0);&#10;&#10;&#9;// Cor (r, g, b)&#10;&#9;glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(3 * sizeof(float)));&#10;&#9;glEnableVertexAttribArray(1);&#10;&#10;&#9;glBindBuffer(GL_ARRAY_BUFFER, 0);&#10;&#9;glBindVertexArray(0);&#10;}&#10;&#10;// Gera uma cor aleatória&#10;vec3 generateRandomColor()&#10;{&#10;&#9;return vec3(&#10;&#9;&#9;(rand() % 256) / 255.0f,  // R&#10;&#9;&#9;(rand() % 256) / 255.0f,  // G&#10;&#9;&#9;(rand() % 256) / 255.0f   // B&#10;&#9;);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/*&#10; * L2_Ex06 - Exercício 6 da Lista 2&#10; * Criar triângulos a partir do clique do mouse&#10; *&#10; * Adaptado por: Rossana Baptista Queiroz&#10; *&#10; * Disciplinas:&#10; *   - Processamento Gráfico (Ciência da Computação - Híbrido)&#10; *   - Processamento Gráfico: Fundamentos (Ciência da Computação - Presencial)&#10; *   - Fundamentos de Computação Gráfica (Jogos Digitais)&#10; *&#10; * Descrição:&#10; *   Este exercício permite criar triângulos clicando na tela. A cada 3 cliques,&#10; *   um novo triângulo é criado com uma cor aleatória.&#10; *&#10; * Histórico:&#10; *   - Versão inicial: 07/04/2017&#10; *   - Última atualização: 18/03/2025&#10; *&#10; */&#10;&#10;#include &lt;iostream&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;ctime&gt;&#10;&#10;using namespace std;&#10;&#10;// GLAD&#10;#include &lt;glad/glad.h&gt;&#10;&#10;// GLFW&#10;#include &lt;GLFW/glfw3.h&gt;&#10;&#10;// GLM&#10;#include &lt;glm/glm.hpp&gt; &#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &lt;glm/gtc/type_ptr.hpp&gt;&#10;&#10;using namespace glm;&#10;&#10;// Estrutura para armazenar vértices&#10;struct Vertex {&#10;    float x, y, z;&#10;    float r, g, b;&#10;};&#10;&#10;// Variáveis globais&#10;vector&lt;Vertex&gt; vertices;&#10;vector&lt;Vertex&gt; currentTriangle;&#10;GLuint VAO, VBO;&#10;int triangleCount = 0;&#10;&#10;// Protótipos das funções&#10;void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode);&#10;void mouse_button_callback(GLFWwindow* window, int button, int action, int mods);&#10;int setupShader();&#10;void updateGeometry();&#10;vec3 generateRandomColor();&#10;&#10;// Dimensões da janela&#10;const GLuint WIDTH = 800, HEIGHT = 600;&#10;&#10;// Código fonte do Vertex Shader (em GLSL)&#10;const GLchar *vertexShaderSource = R&quot;(&#10; #version 400&#10; layout (location = 0) in vec3 position;&#10; layout (location = 1) in vec3 color;&#10; out vec3 vColor; &#10; uniform mat4 projection;&#10; void main()&#10; {&#10;&#9; gl_Position = projection * vec4(position.x, position.y, position.z, 1.0);&#10;&#9; vColor = color;&#10; }&#10; )&quot;;&#10;&#10;// Código fonte do Fragment Shader (em GLSL)&#10;const GLchar *fragmentShaderSource = R&quot;(&#10; #version 400&#10; in vec3 vColor;&#10; out vec4 color;&#10; void main()&#10; {&#10;&#9; color = vec4(vColor,1.0);&#10; }&#10; )&quot;;&#10;&#10;// Função MAIN&#10;int main()&#10;{&#10;&#9;// Inicialização da GLFW&#10;&#9;glfwInit();&#10;&#10;&#9;// Inicializa gerador de números aleatórios&#10;&#9;srand(time(nullptr));&#10;&#10;&#9;// Criação da janela GLFW&#10;&#9;GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, &quot;L2_Ex06 - Criar Triângulos com Mouse -- Taimisson&quot;, nullptr, nullptr);&#10;&#9;if (!window)&#10;&#9;{&#10;&#9;&#9;std::cerr &lt;&lt; &quot;Falha ao criar a janela GLFW&quot; &lt;&lt; std::endl;&#10;&#9;&#9;glfwTerminate();&#10;&#9;&#9;return -1;&#10;&#9;}&#10;&#9;glfwMakeContextCurrent(window);&#10;&#10;&#9;// Registrando callbacks&#10;&#9;glfwSetKeyCallback(window, key_callback);&#10;&#9;glfwSetMouseButtonCallback(window, mouse_button_callback);&#10;&#10;&#9;// GLAD: carrega todos os ponteiros de funções da OpenGL&#10;&#9;if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#10;&#9;{&#10;&#9;&#9;std::cerr &lt;&lt; &quot;Falha ao inicializar GLAD&quot; &lt;&lt; std::endl;&#10;&#9;&#9;return -1;&#10;&#9;}&#10;&#10;&#9;// Obtendo as informações de versão&#10;&#9;const GLubyte *renderer = glGetString(GL_RENDERER);&#10;&#9;const GLubyte *version = glGetString(GL_VERSION);&#10;&#9;cout &lt;&lt; &quot;Renderer: &quot; &lt;&lt; renderer &lt;&lt; endl;&#10;&#9;cout &lt;&lt; &quot;OpenGL version supported &quot; &lt;&lt; version &lt;&lt; endl;&#10;&#10;&#9;// Compilando e buildando o programa de shader&#10;&#9;GLuint shaderID = setupShader();&#10;&#10;&#9;// Configuração inicial do VAO e VBO&#10;&#9;glGenVertexArrays(1, &amp;VAO);&#10;&#9;glGenBuffers(1, &amp;VBO);&#10;&#10;&#9;glUseProgram(shaderID);&#10;&#10;&#9;double prev_s = glfwGetTime();&#10;&#9;double title_countdown_s = 0.1;&#10;&#10;&#9;// Criação da matriz de projeção - coordenadas de tela (0,800,600,0)&#10;&#9;mat4 projection = ortho(0.0f, (float)WIDTH, (float)HEIGHT, 0.0f, -1.0f, 1.0f);&#10;&#10;&#9;// Mandar a matriz de projeção para o shader&#10;&#9;glUniformMatrix4fv(glGetUniformLocation(shaderID, &quot;projection&quot;), 1, GL_FALSE, value_ptr(projection));&#10;&#10;&#9;cout &lt;&lt; &quot;Clique na tela para criar vértices. A cada 3 cliques, um triângulo será criado!&quot; &lt;&lt; endl;&#10;&#9;cout &lt;&lt; &quot;Pressione ESC para sair.&quot; &lt;&lt; endl;&#10;&#10;&#9;// Loop da aplicação - &quot;game loop&quot;&#10;&#9;while (!glfwWindowShouldClose(window))&#10;&#9;{&#10;&#9;&#9;// Calcula e mostra o FPS na barra de título&#10;&#9;&#9;{&#10;&#9;&#9;&#9;double curr_s = glfwGetTime();&#10;&#9;&#9;&#9;double elapsed_s = curr_s - prev_s;&#10;&#9;&#9;&#9;prev_s = curr_s;&#10;&#10;&#9;&#9;&#9;title_countdown_s -= elapsed_s;&#10;&#9;&#9;&#9;if (title_countdown_s &lt;= 0.0 &amp;&amp; elapsed_s &gt; 0.0)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;double fps = 1.0 / elapsed_s;&#10;&#9;&#9;&#9;&#9;char tmp[256];&#10;&#9;&#9;&#9;&#9;sprintf(tmp, &quot;L2_Ex06 - Triângulos: %d, Vértices: %d/3 -- FPS %.2lf&quot;,&#10;&#9;&#9;&#9;&#9;&#9;triangleCount, (int)currentTriangle.size(), fps);&#10;&#9;&#9;&#9;&#9;glfwSetWindowTitle(window, tmp);&#10;&#9;&#9;&#9;&#9;title_countdown_s = 0.1;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Checa eventos de input&#10;&#9;&#9;glfwPollEvents();&#10;&#10;&#9;&#9;// Limpa o buffer de cor&#10;&#9;&#9;glClearColor(0.2f, 0.2f, 0.2f, 1.0f); // Fundo cinza escuro&#10;&#9;&#9;glClear(GL_COLOR_BUFFER_BIT);&#10;&#10;&#9;&#9;// Viewport para tela inteira&#10;&#9;&#9;glViewport(0, 0, WIDTH, HEIGHT);&#10;&#10;&#9;&#9;// Desenha todos os triângulos criados&#10;&#9;&#9;if (!vertices.empty())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;glBindVertexArray(VAO);&#10;&#9;&#9;&#9;glDrawArrays(GL_TRIANGLES, 0, vertices.size());&#10;&#9;&#9;&#9;glBindVertexArray(0);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Desenha os vértices do triângulo atual sendo criado como pontos&#10;&#9;&#9;if (!currentTriangle.empty())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;glPointSize(8.0f);&#10;&#10;&#9;&#9;&#9;// Cria um VAO temporário para os pontos&#10;&#9;&#9;&#9;GLuint tempVAO, tempVBO;&#10;&#9;&#9;&#9;glGenVertexArrays(1, &amp;tempVAO);&#10;&#9;&#9;&#9;glGenBuffers(1, &amp;tempVBO);&#10;&#10;&#9;&#9;&#9;glBindVertexArray(tempVAO);&#10;&#9;&#9;&#9;glBindBuffer(GL_ARRAY_BUFFER, tempVBO);&#10;&#9;&#9;&#9;glBufferData(GL_ARRAY_BUFFER, currentTriangle.size() * sizeof(Vertex), currentTriangle.data(), GL_DYNAMIC_DRAW);&#10;&#10;&#9;&#9;&#9;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);&#10;&#9;&#9;&#9;glEnableVertexAttribArray(0);&#10;&#9;&#9;&#9;glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(3 * sizeof(float)));&#10;&#9;&#9;&#9;glEnableVertexAttribArray(1);&#10;&#10;&#9;&#9;&#9;glDrawArrays(GL_POINTS, 0, currentTriangle.size());&#10;&#10;&#9;&#9;&#9;// Limpa VAO temporário&#10;&#9;&#9;&#9;glDeleteVertexArrays(1, &amp;tempVAO);&#10;&#9;&#9;&#9;glDeleteBuffers(1, &amp;tempVBO);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Troca os buffers da tela&#10;&#9;&#9;glfwSwapBuffers(window);&#10;&#9;}&#10;&#10;&#9;// Limpeza&#10;&#9;glDeleteVertexArrays(1, &amp;VAO);&#10;&#9;glDeleteBuffers(1, &amp;VBO);&#10;&#9;glfwTerminate();&#10;&#9;return 0;&#10;}&#10;&#10;// Função de callback de teclado&#10;void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode)&#10;{&#10;&#9;if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)&#10;&#9;&#9;glfwSetWindowShouldClose(window, GL_TRUE);&#10;}&#10;&#10;// Função de callback do mouse&#10;void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)&#10;{&#10;&#9;if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; action == GLFW_PRESS)&#10;&#9;{&#10;&#9;&#9;double xpos, ypos;&#10;&#9;&#9;glfwGetCursorPos(window, &amp;xpos, &amp;ypos);&#10;&#10;&#9;&#9;// Converte coordenadas da tela para coordenadas do mundo&#10;&#9;&#9;float worldX = (float)xpos;&#10;&#9;&#9;float worldY = (float)ypos;&#10;&#10;&#9;&#9;// Gera cor para este vértice (será a cor do triângulo quando completado)&#10;&#9;&#9;static vec3 currentColor = generateRandomColor();&#10;&#10;&#9;&#9;// Cria o vértice&#10;&#9;&#9;Vertex vertex;&#10;&#9;&#9;vertex.x = worldX;&#10;&#9;&#9;vertex.y = worldY;&#10;&#9;&#9;vertex.z = 0.0f;&#10;&#9;&#9;vertex.r = currentColor.r;&#10;&#9;&#9;vertex.g = currentColor.g;&#10;&#9;&#9;vertex.b = currentColor.b;&#10;&#10;&#9;&#9;// Adiciona o vértice ao triângulo atual&#10;&#9;&#9;currentTriangle.push_back(vertex);&#10;&#10;&#9;&#9;cout &lt;&lt; &quot;Vértice &quot; &lt;&lt; currentTriangle.size() &lt;&lt; &quot; criado em (&quot; &lt;&lt; worldX &lt;&lt; &quot;, &quot; &lt;&lt; worldY &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#10;&#10;&#9;&#9;// Se completou um triângulo (3 vértices)&#10;&#9;&#9;if (currentTriangle.size() == 3)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// Adiciona os 3 vértices aos triângulos finalizados&#10;&#9;&#9;&#9;for (const auto&amp; v : currentTriangle)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;vertices.push_back(v);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;triangleCount++;&#10;&#9;&#9;&#9;cout &lt;&lt; &quot;Triângulo &quot; &lt;&lt; triangleCount &lt;&lt; &quot; criado!&quot; &lt;&lt; endl;&#10;&#10;&#9;&#9;&#9;// Atualiza a geometria no OpenGL&#10;&#9;&#9;&#9;updateGeometry();&#10;&#10;&#9;&#9;&#9;// Limpa o triângulo atual e gera nova cor para o próximo&#10;&#9;&#9;&#9;currentTriangle.clear();&#10;&#9;&#9;&#9;currentColor = generateRandomColor();&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// Função para configurar os shaders&#10;int setupShader()&#10;{&#10;&#9;// Vertex shader&#10;&#9;GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);&#10;&#9;glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);&#10;&#9;glCompileShader(vertexShader);&#10;&#10;&#9;GLint success;&#10;&#9;GLchar infoLog[512];&#10;&#9;glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;// Fragment shader&#10;&#9;GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);&#10;&#9;glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);&#10;&#9;glCompileShader(fragmentShader);&#10;&#10;&#9;glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;// Linkando os shaders&#10;&#9;GLuint shaderProgram = glCreateProgram();&#10;&#9;glAttachShader(shaderProgram, vertexShader);&#10;&#9;glAttachShader(shaderProgram, fragmentShader);&#10;&#9;glLinkProgram(shaderProgram);&#10;&#10;&#9;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);&#10;&#9;if (!success)&#10;&#9;{&#10;&#9;&#9;glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);&#10;&#9;&#9;std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#10;&#9;}&#10;&#10;&#9;glDeleteShader(vertexShader);&#10;&#9;glDeleteShader(fragmentShader);&#10;&#10;&#9;return shaderProgram;&#10;}&#10;&#10;// Atualiza a geometria no OpenGL&#10;void updateGeometry()&#10;{&#10;&#9;if (vertices.empty()) return;&#10;&#10;&#9;glBindVertexArray(VAO);&#10;&#9;glBindBuffer(GL_ARRAY_BUFFER, VBO);&#10;&#10;&#9;// Envia todos os vértices para o buffer&#10;&#9;glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_DYNAMIC_DRAW);&#10;&#10;&#9;// Configura os atributos dos vértices&#10;&#9;// Posição (x, y, z)&#10;&#9;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);&#10;&#9;glEnableVertexAttribArray(0);&#10;&#10;&#9;// Cor (r, g, b)&#10;&#9;glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(3 * sizeof(float)));&#10;&#9;glEnableVertexAttribArray(1);&#10;&#10;&#9;glBindBuffer(GL_ARRAY_BUFFER, 0);&#10;&#9;glBindVertexArray(0);&#10;}&#10;&#10;// Gera uma cor aleatória&#10;vec3 generateRandomColor()&#10;{&#10;&#9;return vec3(&#10;&#9;&#9;(rand() % 256) / 255.0f,  // R&#10;&#9;&#9;(rand() % 256) / 255.0f,  // G&#10;&#9;&#9;(rand() % 256) / 255.0f   // B&#10;&#9;);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>